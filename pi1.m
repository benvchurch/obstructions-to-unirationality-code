/* forms the free group generated by e1, ..., e5 subject to the relations e1 * ... * e5 = id and e_i^(Order(seq_i)) = id where seq_i is a sequence of elements of a group G which is the monodromy group of the covering */

/* WHY GENERATED BY ONLY 5 ELEMENTS? */

PolyGroup:=function(seq)
F:=FreeGroup(#seq);
P:=quo<F | F.1^Order(seq[1]), F.2^Order(seq[2]), F.3^Order(seq[3]),
F.4^Order(seq[4]), F.5^Order(seq[5]), F.1*F.2*F.3*F.4*F.5>;
return P, hom<P->Parent(seq[1])|seq>;
end function;

Pi1:=function(seq1,seq2) /* the arguments are sequences of elements of the monodromy group G */
T1:=PolyGroup(seq1); T2,f2:=PolyGroup(seq2); G:=Parent(seq1[1]);
T1xT2:=DirectProduct(T1,T2);
inT2:=hom< T2->T1xT2 | [T1xT2.6, T1xT2.7, T1xT2.8, T1xT2.9, T1xT2.10]>;
GxG,inG:=DirectProduct(G,G); m:=NumberOfGenerators(G); L:=[ ];
for i in [1..m] do Append(~L,GxG.i*GxG.(i+m)); end for;
Diag:=hom<G->GxG|L>(G);
f:=hom<T1xT2->GxG|
inG[1](seq1[1]),inG[1](seq1[2]),inG[1](seq1[3]),
inG[1](seq1[4]),inG[1](seq1[5]),
inG[2](seq2[1]),inG[2](seq2[2]),inG[2](seq2[3]),
inG[2](seq2[4]),inG[2](seq2[5])>;
H:=Rewrite(T1xT2,Diag@@f); TorsH:=[ ];
for i in [1..5] do if IsEven(Order(seq1[i])) then
for j in [1..5] do if IsEven(Order(seq2[j])) then
a:=IntegerRing()!(Order(seq1[i])/2); b:=IntegerRing()!(Order(seq2[j])/2);
test,h:= IsConjugate(G,seq1[i]^a,seq2[j]^b);
if test then for c in Centralizer(G,seq1[i]^a) do
Append(~TorsH, T1xT2.i^a * ((T1xT2.(j+5)^b)^(inT2((h^-1*c) @@ f2))));
end for; end if;
end if; end for; end if; end for;
return Simplify(quo<H | TorsH>);
end function;

/* This following script does the same computation as the previous one,
but instead of returning the fundamental group as astract group it
returns T1xT2, H as subgroup of T1xT2 and a list of generators of
Tors(H) */

Pi1Detailed:=function(seq1,seq2)
T1:=PolyGroup(seq1); T2,f2:=PolyGroup(seq2); G:=Parent(seq1[1]);
T1xT2:=DirectProduct(T1,T2);
inT2:=hom< T2->T1xT2 | [T1xT2.6, T1xT2.7, T1xT2.8, T1xT2.9, T1xT2.10]>;
GxG,inG:=DirectProduct(G,G); m:=NumberOfGenerators(G); L:=[ ];
for i in [1..m] do Append(~L,GxG.i*GxG.(i+m)); end for;
Diag:=hom<G->GxG|L>(G);
f:=hom<T1xT2->GxG|
inG[1](seq1[1]),inG[1](seq1[2]),inG[1](seq1[3]),
inG[1](seq1[4]),inG[1](seq1[5]),
inG[2](seq2[1]),inG[2](seq2[2]),inG[2](seq2[3]),
inG[2](seq2[4]),inG[2](seq2[5])>;
H:=Rewrite(T1xT2,Diag@@f); TorsH:=[ ];
for i in [1..5] do if IsEven(Order(seq1[i])) then
for j in [1..5] do if IsEven(Order(seq2[j])) then
a:=IntegerRing()!(Order(seq1[i])/2); b:=IntegerRing()!(Order(seq2[j])/2);
test,h:= IsConjugate(G,seq1[i]^a,seq2[j]^b);
if test then for c in Centralizer(G,seq1[i]^a) do
Append(~TorsH, T1xT2.i^a * ((T1xT2.(j+5)^b)^(inT2((h^-1*c) @@ f2))));
end for; end if;
end if; end for; end if; end for;
return T1xT2,H, TorsH;
end function;

G := CyclicGroup(2);
a := G.1;

seq1 := [a, a, a, a, a^2];
seq2 := [a, a, a, a, a^2];

Order(Pi1(seq1, seq2));
