/*******************************************************************************
 * pi1_tests.m
 *
 * Purpose:
 *   Multiple implementations and tests for computing fundamental groups of
 *   product-quotient surfaces. Contains old, new, and modified versions.
 *
 * Functions:
 *   - PolyGroup(seq): Create polygon group from spherical generators (5 elements)
 *   - Pi1(seq1, seq2): Original Pi1 computation (hardcoded for 5 generators)
 *   - Pi1Detailed(seq1, seq2): Returns detailed group structure information
 *   - PolyGroup(seq, gr): Generalized polygon group (any length)
 *   - DirProd(G1, G2): Direct product with explicit injection/projection maps
 *   - MapProd(map1, map2): Product of two homomorphisms
 *   - Pi1_v2(pairsofseqs, gr): Generalized Pi1 (any length sequences)
 *   - Pi1_v2_modified: Variant without spherical product relation
 *   - Pi1_v3: Version with input validation via Checks
 *
 * Test examples:
 *   - DihedralGroup(6), DihedralGroup(7) examples
 *   - AlternatingGroup(4) examples
 *   - S8 subgroup example
 *
 * Dependencies:
 *   - invariants.m: Checks function
 *   - group_reps.m: SphGensUptoConj
 *
 * Note:
 *   Contains multiple versions of the same computation for comparison and
 *   testing purposes. The main version used elsewhere is MyPi1 in invariants.m.
 ******************************************************************************/

// Add these import statements at the beginning of the file
import "invariants.m": Checks;
import "group_reps.m": SphGensUptoConj;

// this the the OLD code for computing pi1
/* forms the free group generated by e1, ..., e5 subject to the relations e1 * ... * e5 = id and e_i^(Order(seq_i)) = id where seq_i is a sequence of elements of a group G which is the monodromy group of the covering */

/* WHY GENERATED BY ONLY 5 ELEMENTS? */

PolyGroup:=function(seq)
F:=FreeGroup(#seq);
P:=quo<F | F.1^Order(seq[1]), F.2^Order(seq[2]), F.3^Order(seq[3]),
F.4^Order(seq[4]), F.5^Order(seq[5]), F.1*F.2*F.3*F.4*F.5>;
return P, hom<P->Parent(seq[1])|seq>;
end function;

Pi1:=function(seq1,seq2) /* the arguments are sequences of elements of the monodromy group G */
T1:=PolyGroup(seq1); T2,f2:=PolyGroup(seq2); G:=Parent(seq1[1]);
T1xT2:=DirectProduct(T1,T2);
inT2:=hom< T2->T1xT2 | [T1xT2.6, T1xT2.7, T1xT2.8, T1xT2.9, T1xT2.10]>;
GxG,inG:=DirectProduct(G,G); m:=NumberOfGenerators(G); L:=[ ];
for i in [1..m] do Append(~L,GxG.i*GxG.(i+m)); end for;
Diag:=hom<G->GxG|L>(G);
f:=hom<T1xT2->GxG|
inG[1](seq1[1]),inG[1](seq1[2]),inG[1](seq1[3]),
inG[1](seq1[4]),inG[1](seq1[5]),
inG[2](seq2[1]),inG[2](seq2[2]),inG[2](seq2[3]),
inG[2](seq2[4]),inG[2](seq2[5])>;
H:=Rewrite(T1xT2,Diag@@f); TorsH:=[ ];
for i in [1..5] do if IsEven(Order(seq1[i])) then
for j in [1..5] do if IsEven(Order(seq2[j])) then
a:=IntegerRing()!(Order(seq1[i])/2); b:=IntegerRing()!(Order(seq2[j])/2);
test,h:= IsConjugate(G,seq1[i]^a,seq2[j]^b);
if test then for c in Centralizer(G,seq1[i]^a) do
Append(~TorsH, T1xT2.i^a * ((T1xT2.(j+5)^b)^(inT2((h^-1*c) @@ f2))));
end for; end if;
end if; end for; end if; end for;
return Simplify(quo<H | TorsH>);
end function;

/* This following script does the same computation as the previous one,
but instead of returning the fundamental group as astract group it
returns T1xT2, H as subgroup of T1xT2 and a list of generators of
Tors(H) */

Pi1Detailed:=function(seq1,seq2)
T1:=PolyGroup(seq1); T2,f2:=PolyGroup(seq2); G:=Parent(seq1[1]);
T1xT2:=DirectProduct(T1,T2);
inT2:=hom< T2->T1xT2 | [T1xT2.6, T1xT2.7, T1xT2.8, T1xT2.9, T1xT2.10]>;
GxG,inG:=DirectProduct(G,G); m:=NumberOfGenerators(G); L:=[ ];
for i in [1..m] do Append(~L,GxG.i*GxG.(i+m)); end for;
Diag:=hom<G->GxG|L>(G);
f:=hom<T1xT2->GxG|
inG[1](seq1[1]),inG[1](seq1[2]),inG[1](seq1[3]),
inG[1](seq1[4]),inG[1](seq1[5]),
inG[2](seq2[1]),inG[2](seq2[2]),inG[2](seq2[3]),
inG[2](seq2[4]),inG[2](seq2[5])>;
H:=Rewrite(T1xT2,Diag@@f); TorsH:=[ ];
for i in [1..5] do if IsEven(Order(seq1[i])) then
for j in [1..5] do if IsEven(Order(seq2[j])) then
a:=IntegerRing()!(Order(seq1[i])/2); b:=IntegerRing()!(Order(seq2[j])/2);
test,h:= IsConjugate(G,seq1[i]^a,seq2[j]^b);
if test then for c in Centralizer(G,seq1[i]^a) do
Append(~TorsH, T1xT2.i^a * ((T1xT2.(j+5)^b)^(inT2((h^-1*c) @@ f2))));
end for; end if;
end if; end for; end if; end for;
return T1xT2,H, TorsH;
end function;


/// FROM SECOND CODE BASE


PolyGroup:=function(seq,gr)
  F:=FreeGroup(#seq); 
  R:={F![1..#seq]};
  for i in [1..#seq] do
    Include(~R,F.i^Order(seq[i]));
  end for;
  P:=quo<F|R>;
  return P, hom<P->gr|seq>;
end function;

PolyGroupModified:=function(seq,gr)
  F:=FreeGroup(#seq); 
  R:={};
  for i in [1..#seq] do
    Include(~R,F.i^Order(seq[i]));
  end for;
  P:=quo<F|R>;
  return P, hom<P->gr|seq>;
end function;

DirProd:=function(G1,G2)
  G1xG2:=DirectProduct(G1,G2); vars:=[];
  n:=[NumberOfGenerators(G1),NumberOfGenerators(G2)];
   for i in [1..n[1]+n[2]] do Append(~vars,G1xG2.i); end for;
   SplittedVars:=Partition(vars,n);
   injs:=[hom< G1->G1xG2 | SplittedVars[1]>,
          hom< G2->G1xG2 | SplittedVars[2]>];
   vars1:=[]; vars2:=[];
   for i in [1..n[1]] do 
     Append(~vars1,G1.i); Append(~vars2,G2!1); 
   end for;
   for i in [1..n[2]] do 
     Append(~vars1,G1!1); Append(~vars2,G2.i); 
   end for;
   projs:=[hom< G1xG2->G1 | vars1>,hom< G1xG2->G2 | vars2>];
  return G1xG2, injs, projs;
end function;

// The next script computes, given two maps A->B (careful, they 
// MUST have same source and same target) the map product 
// induced by the product on B

MapProd:=function(map1,map2)
  seq:=[]; G:=Domain(map1); H:=Codomain(map1);
  if Category(G) eq GrpPC then n:=NPCgens(G); 
  else n:=NumberOfGenerators(G); end if;
  for i in [1..n] do Append(~seq,map1(G.i)*map2(G.i)); end for;
  return hom<G->H|seq>;
end function;

// Finally, this program computes the fundamental group of a 
// product-quotient surface.

Pi1_v2:=function(pairsofseqs,gr)
  T1,f1:=PolyGroup(pairsofseqs[1],gr); 
  T2,f2:=PolyGroup(pairsofseqs[2],gr);
  T1xT2,inT,proT:=DirProd(T1,T2); 
  grxgr,inG:=DirectProduct(gr,gr);
  Diag:=MapProd(inG[1],inG[2])(gr);
  f:=MapProd(proT[1]*f1*inG[1],proT[2]*f2*inG[2]);
  H:=Rewrite(T1xT2,Diag@@f); rels:=[];
  for i in [1..#pairsofseqs[1]] do g1:=pairsofseqs[1][i];
  for j in [1..#pairsofseqs[2]] do g2:=pairsofseqs[2][j];
  for d1 in [1..Order(g1)-1] do
  for d2 in [1..Order(g2)-1] do
    test,h:=IsConjugate(gr,g1^d1,g2^d2);
    if test then for c in Centralizer(gr,g1^d1) do
     Append(~rels, T1xT2.i^d1 * 
            (((T1xT2.(j+#pairsofseqs[1]))^d2)^(inT[2]((h^-1*c) @@ f2))));
    end for; end if;
  end for; end for; end for; end for;
  return Simplify(quo<H|rels>);
end function;


Pi1_v2_modified:=function(pairsofseqs,gr)
  T1,f1:=PolyGroupModified(pairsofseqs[1],gr); 
  T2,f2:=PolyGroupModified(pairsofseqs[2],gr);
  T1xT2,inT,proT:=DirProd(T1,T2); 
  grxgr,inG:=DirectProduct(gr,gr);
  Diag:=MapProd(inG[1],inG[2])(gr);
  f:=MapProd(proT[1]*f1*inG[1],proT[2]*f2*inG[2]);
  H:=Rewrite(T1xT2,Diag@@f); rels:=[];
  for i in [1..#pairsofseqs[1]] do g1:=pairsofseqs[1][i];
  for j in [1..#pairsofseqs[2]] do g2:=pairsofseqs[2][j];
  for d1 in [1..Order(g1)-1] do
  for d2 in [1..Order(g2)-1] do
    test,h:=IsConjugate(gr,g1^d1,g2^d2);
    if test then for c in Centralizer(gr,g1^d1) do
     Append(~rels, T1xT2.i^d1 * 
            (((T1xT2.(j+#pairsofseqs[1]))^d2)^(inT[2]((h^-1*c) @@ f2))));
    end for; end if;
  end for; end for; end for; end for;
  return Simplify(quo<H|rels>);
end function;


// this is the version I have been using in my code 

Pi1_v3:=function(pairsofseqs,gr)
  Checks(pairsofseqs, gr);
  T1,f1:=PolyGroup(pairsofseqs[1],gr); 
  T2,f2:=PolyGroup(pairsofseqs[2],gr);
  T1xT2,inT,proT:=DirProd(T1,T2); 
  grxgr,inG:=DirectProduct(gr,gr);
  Diag:=MapProd(inG[1],inG[2])(gr);
  f:=MapProd(proT[1]*f1*inG[1],proT[2]*f2*inG[2]);
  
  // Get the preimage of the diagonal
  H, rewrite_map := Rewrite(T1xT2,Diag@@f);
  
  // Create additional relations
  torsion_rels := [];

  for i in [1..#pairsofseqs[1]] do
    g1 := pairsofseqs[1][i];
    for j in [1..#pairsofseqs[2]] do
      g2 := pairsofseqs[2][j];
      for d1 in [1..Order(g1) - 1] do
        for d2 in [1..Order(g2) - 1] do
          test, h := IsConjugate(gr, g1^d1, g2^d2);
          if test then
            for c in Centralizer(gr, g1^d1) do
              rel := T1xT2.i^d1 * ((T1xT2.(j + #pairsofseqs[1])^d2)^(inT[2]((h^-1 * c) @@ f2)));
              if not rel in Domain(rewrite_map) then
                print "issue";
              else
                Append(~torsion_rels, rewrite_map(rel));
              end if;
            end for;
          end if;
        end for;
      end for;
    end for;
  end for;
  // Return the quotient
  return Simplify(quo<H | torsion_rels>);
end function;


G := DihedralGroup(6);
conj := [2, 3, 4, 4, 4, 4, 4, 5];

gens := SphGensUptoConj(G, conj);

for gen in gens do
  print Order(Pi1_v2([gen, gen], G));
end for;

if false then


G := DihedralGroup(7);
conj := [2, 2, 2, 2, 2, 2, 5];
gens := SphGensUptoConj(G, conj);

for gen in gens do
  print Order(Pi1_v2_modified([gen, gen], G));
end for;


G := DihedralGroup(6);
conj := [2, 3, 3, 3, 4, 4, 4, 5];
gens := SphGensUptoConj(G, conj);

for gen in gens do
  print Order(Pi1_v2([gen, gen], G));
end for;

G := AlternatingGroup(4);
conj := [2,2,2,4,3,3,4];
gens := SphGensUptoConj(G, conj);

for gen in gens do
  print Order(Pi1_v2_modified([gen, gen], G));
end for;


// where does this example come from? Maybe Pries?
S8 := SymmetricGroup(8);
G := sub<S8| (3,6,7)(4,5,8), (1,8,2)(4,5,6)>;
x1 := G ! (1,8,2,4,3,7,5);
x2 := G ! (1,3,6)(2,8,4);
x3 := G ! (1,6,4)(3,5,7);

y1 := G ! (1,6,5,8,3,2,7);
y2 := G ! (1,4,7,8)(2,6,5,3);
y3 := (y1*y2)^(-1);

seq1 := [x1,x2,x3];
seq2 := [y1,y2,y3];

cl := ClassMap(G);


P := Pi1_v2_modified([seq1, seq2], G);



end if;

