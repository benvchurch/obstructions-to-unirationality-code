/*******************************************************************************
 * tau_matrix.m
 *
 * Compute the full matrix of τ on J[2] = (Z/2Z)^6 for C2 at p=17,
 * then compute the fixed subspace and determine if J[2](Q) can be preserved.
 *
 * Uses the Riemann-Roch function pullback approach.
 ******************************************************************************/

function J2Subgroup(Cl, invs)
    gens := [];
    for i in [1..#invs] do
        if invs[i] ne 0 and invs[i] mod 2 eq 0 then
            Append(~gens, (invs[i] div 2) * Cl.i);
        end if;
    end for;
    if #gens eq 0 then return sub<Cl | Cl!0>; end if;
    return sub<Cl | gens>;
end function;

// Compute τ*(f) for f in FF2, where τ: (t,u) -> (t/i, u/i)
function TauPullback(f, FF, gen_u, base_t, inv_i)
    elt := ElementToSequence(f);
    result := FF!0;
    for j in [1..#elt] do
        num := Numerator(elt[j]);
        den := Denominator(elt[j]);
        num_sub := Evaluate(num, base_t * inv_i);
        den_sub := Evaluate(den, base_t * inv_i);
        a_sub := num_sub / den_sub;
        result := result + (FF!a_sub) * gen_u^(j-1) * (FF!inv_i)^(j-1);
    end for;
    return result;
end function;

// Compute τ*(g) for g in J[2], using Riemann-Roch to find the representing function
function TauOnJ2(g, mm, FF, gen_u, base_t, inv_i, Cl)
    D := mm(g);
    neg2D := -2*D;
    V, phi_V := RiemannRochSpace(neg2D);
    assert Dimension(V) ge 1;
    f_g := phi_V(V.1);

    tau_fg := TauPullback(f_g, FF, gen_u, base_t, inv_i);

    // div(tau_fg) = 2*τ*(D). Take half to get τ*(D).
    div_tau := Divisor(tau_fg);
    supp_tau := Support(div_tau);
    half_div := DivisorGroup(FF) ! 0;
    for P in supp_tau do
        val := Valuation(div_tau, P);
        assert val mod 2 eq 0;
        half_div := half_div + (val div 2) * (1*P);
    end for;

    return half_div @@ mm;
end function;

// =========================================================================
// Setup at p=17
// =========================================================================
p := 17;
Fp := GF(p);
ii := Fp!0;
for x in Fp do
    if x ne 0 and x^2 eq Fp!(-1) then ii := x; break; end if;
end for;
inv_i := Fp!(1/ii);

Fpt<tt> := FunctionField(Fp);
Fptu<uu> := PolynomialRing(Fpt);
FF2<vv> := FunctionField(uu^4 + tt^4 - 1);
Cl2, mm2 := ClassGroup(FF2);
invs2 := Invariants(Cl2);
J2_sub := J2Subgroup(Cl2, invs2);
printf "p=%o, i=%o, Cl=%o, |J[2]|=%o\n\n", p, ii, invs2, #J2_sub;

// =========================================================================
// Compute J[2] generators
// =========================================================================
j2_gens := [];
j2_gen_indices := [];
for k in [1..#invs2] do
    if invs2[k] eq 0 then continue; end if;
    if invs2[k] mod 2 ne 0 then continue; end if;
    g := (invs2[k] div 2) * Cl2.k;
    Append(~j2_gens, g);
    Append(~j2_gen_indices, k);
end for;
n := #j2_gens;
printf "J[2] has %o generators (dim = %o over F_2)\n", n, n;

// =========================================================================
// Compute τ on each generator
// =========================================================================
printf "\nτ action on generators:\n";
tau_images := [];
for idx in [1..n] do
    g := j2_gens[idx];
    tau_g := TauOnJ2(g, mm2, FF2, vv, tt, inv_i, Cl2);
    Append(~tau_images, tau_g);
    printf "  g%o = %o -> τ(g%o) = %o  (same? %o)\n",
        idx, g, idx, tau_g, tau_g eq g;
end for;

// =========================================================================
// Express τ(g_i) in terms of the J[2] basis
// Each J[2] element can be written as sum of generators (F_2 coefficients).
// We need to express tau_images[i] in terms of j2_gens.
// =========================================================================
printf "\n=== τ MATRIX OVER F_2 ===\n";

// Build F_2 vector space
V2 := VectorSpace(GF(2), n);
// Map: J[2] element -> F_2 vector
// Since J2_sub is generated by j2_gens (each order 2), every element is
// a unique sum of subset of generators.

// To express an element h of J[2] as a vector:
// For each generator position i, check if h - g_i is "simpler"
// Actually, we need to solve: h = sum a_i * g_i in the abelian group.

function J2ToVector(h, gens, J2, Cl)
    // Brute force: enumerate all 2^n vectors and find the match
    n := #gens;
    for bits in [0..2^n-1] do
        sum := Cl!0;
        for i in [1..n] do
            if (bits div 2^(i-1)) mod 2 eq 1 then
                sum := sum + gens[i];
            end if;
        end for;
        if sum eq h then
            v := [];
            for i in [1..n] do
                Append(~v, GF(2)!((bits div 2^(i-1)) mod 2));
            end for;
            return V2!v;
        end if;
    end for;
    error "Element not found in J[2]";
end function;

// Build the matrix
T := ZeroMatrix(GF(2), n, n);
for idx in [1..n] do
    vec := J2ToVector(tau_images[idx], j2_gens, J2_sub, Cl2);
    for j in [1..n] do
        T[idx][j] := vec[j];
    end for;
    printf "  τ(g%o) = %o\n", idx, vec;
end for;

printf "\nMatrix T (rows = images of basis vectors):\n%o\n", T;

// =========================================================================
// Verify T^2 = I (since τ^2 = negation acts trivially on J[2])
// =========================================================================
T2 := T^2;
I_n := IdentityMatrix(GF(2), n);
printf "\nT^2 = I? %o\n", T2 eq I_n;

// =========================================================================
// Fixed subspace: ker(T - I) = ker(T + I) (over F_2, -1 = 1)
// =========================================================================
TpI := T + I_n;
K := NullSpace(TpI);
printf "\nFixed subspace of τ: dim = %o\n", Dimension(K);
printf "Basis of fixed subspace:\n";
for b in Basis(K) do
    printf "  %o = ", b;
    first := true;
    for i in [1..n] do
        if b[i] eq 1 then
            if not first then printf " + "; end if;
            printf "g%o", i;
            first := false;
        end if;
    end for;
    printf "\n";
end for;

// =========================================================================
// CONCLUSION
// =========================================================================
fixed_dim := Dimension(K);
j2q_dim := 3;  // J[2](Q) = (Z/2Z)^3 for both curves
printf "\n=== CONCLUSION ===\n";
printf "dim(τ-fixed subspace of J[2]) = %o\n", fixed_dim;
printf "dim(J[2](Q)) = %o\n", j2q_dim;

if fixed_dim lt j2q_dim then
    printf "\nSince dim(τ-fixed) = %o < %o = dim(J[2](Q)),\n", fixed_dim, j2q_dim;
    printf "the 3-dimensional subspace φ_*(J[2](Q)_{C1}) CANNOT lie inside\n";
    printf "the %o-dimensional τ-fixed subspace.\n", fixed_dim;
    printf "\nBut for φ_*(J[2](Q)_{C1}) = J[2](Q)_{C2}, we need τ to fix\n";
    printf "φ_*(J[2](Q)_{C1}) (because the twist cocycle involves τ for σ\n";
    printf "not fixing i, and the Galois action on C2 includes the cocycle).\n";
    printf "\n*** J[2](Q) for C1 and C2 are NOT the same under φ. ***\n";
elif fixed_dim ge j2q_dim then
    printf "\ndim(τ-fixed) = %o >= %o = dim(J[2](Q))\n", fixed_dim, j2q_dim;
    printf "The subspaces MIGHT be the same — further analysis needed.\n";
end if;

// Also verify at p=5 for consistency
printf "\n\n=== VERIFICATION AT p=5 ===\n";
p2 := 5;
Fp2 := GF(p2);
ii2 := Fp2!0;
for x in Fp2 do
    if x ne 0 and x^2 eq Fp2!(-1) then ii2 := x; break; end if;
end for;
inv_i2 := Fp2!(1/ii2);

Fpt2<tt2> := FunctionField(Fp2);
Fptu2<uu2> := PolynomialRing(Fpt2);
FF2b<vv2> := FunctionField(uu2^4 + tt2^4 - 1);
Cl2b, mm2b := ClassGroup(FF2b);
invs2b := Invariants(Cl2b);
J2b := J2Subgroup(Cl2b, invs2b);
printf "p=%o, Cl=%o, |J[2]|=%o\n", p2, invs2b, #J2b;

j2b_gens := [];
for k in [1..#invs2b] do
    if invs2b[k] eq 0 then continue; end if;
    if invs2b[k] mod 2 ne 0 then continue; end if;
    Append(~j2b_gens, (invs2b[k] div 2) * Cl2b.k);
end for;
nb := #j2b_gens;
printf "J[2] dim = %o\n", nb;

tau_images_b := [];
for idx in [1..nb] do
    g := j2b_gens[idx];
    tau_g := TauOnJ2(g, mm2b, FF2b, vv2, tt2, inv_i2, Cl2b);
    Append(~tau_images_b, tau_g);
end for;

V2b := VectorSpace(GF(2), nb);

function J2ToVectorB(h, gens, J2, Cl, V)
    n := #gens;
    for bits in [0..2^n-1] do
        sum := Cl!0;
        for i in [1..n] do
            if (bits div 2^(i-1)) mod 2 eq 1 then
                sum := sum + gens[i];
            end if;
        end for;
        if sum eq h then
            v := [];
            for i in [1..n] do
                Append(~v, GF(2)!((bits div 2^(i-1)) mod 2));
            end for;
            return V!v;
        end if;
    end for;
    error "Element not found in J[2]";
end function;

Tb := ZeroMatrix(GF(2), nb, nb);
for idx in [1..nb] do
    vec := J2ToVectorB(tau_images_b[idx], j2b_gens, J2b, Cl2b, V2b);
    for j in [1..nb] do
        Tb[idx][j] := vec[j];
    end for;
end for;

Tb2 := Tb^2;
Ib := IdentityMatrix(GF(2), nb);
printf "T^2 = I? %o\n", Tb2 eq Ib;

TbpI := Tb + Ib;
Kb := NullSpace(TbpI);
printf "Fixed subspace of τ at p=5: dim = %o (out of %o)\n", Dimension(Kb), nb;

quit;
