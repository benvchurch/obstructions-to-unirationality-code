// Import intermediate extension functionality
import "intermediate_extensions.m": GenusIntermediateExtension, Genus, 
    IntermediateMonodromy, GetMonodromyIntermediateExtension;

// computes the Q-decomposition of the representation of G on rational cohomology

getRam := function(cycle)
    str := CycleStructure(cycle);
    ram := 0;
    for p in str do
        ram := ram + (p[1]-1)*p[2];
    end for;
    return ram;
end function;

computeRationalCohomology := function(G, seq) // compute the decomposition of the representation of G on rational cohomology in terms of Q-irreps
    K := Rationals();
    irreps := IrreducibleModules(G, K);
    mat := []; // matrix of the fixed dimensions
    g := []; // vector of twice the genus
    ords := [];
    for ref in Subgroups(G) do
        H := ref`subgroup;
        genus := GenusIntermediateExtension(G, seq, H);
        if Order(H) eq 1 then 
            Append(~mat, [Dimension(M) : M in irreps]);
        else 
            N := Induction(IrreducibleModules(H, K)[1], G);
            Append(~mat, [InnerProduct(Character(M), Character(N)) : M in irreps]);
        end if;
        Append(~g, 2*genus);
        Append(~ords, Order(H));
    end for;

    mat := Matrix(K, mat);
    g := Matrix(K, 1, #g, g);

    v, ker := Solution(Transpose(mat), g);
    print "Ambiguity: ", not (Dimension(ker) eq 0);
    return v;
end function;


computeGroupRingDecomposition := function(G)
    K := Rationals();
    irreps := IrreducibleModules(G, K);
    for M in irreps do 
        print "dim, dim(D), n: ", Dimension(M), InnerProduct(Character(M), Character(M)), Dimension(M) / InnerProduct(Character(M), Character(M));
    end for;
    return "";
end function;

// this restricts each irrep to the subgroup H and computes the number of trivial copies, used for computing the map between group rings
/*
H := Subgroups(G)[2]`subgroup;
for M in irreps do 
    W := Restriction(M, H);
    for R in Decomposition(W) do
        print InnerProduct(Character(R), Character(IrreducibleModules(H,K)[1]));
    end for;
    print "";
end for;
*/



FindBelyiCurve := function(G, conj, genus) // finds a curve presented as a G-cover of P1 ramified at 3 points with the given conjugacy classes and genus 
    conjClasses := ConjugacyClasses(G);
    el_Conj_1 := [g : g in G | IsConjugate(G, g, conjClasses[conj[1]][3])];
    el_Conj_2 := [g : g in G | IsConjugate(G, g, conjClasses[conj[2]][3])];
    el_Conj_3 := [g : g in G | IsConjugate(G, g, conjClasses[conj[3]][3])];
    for g1 in el_Conj_1 do
        for g2 in el_Conj_2 do
            for g3 in el_Conj_3 do
                if g1 * g2 * g3 eq Id(G) and Genus(G, [g1, g2, g3]) eq genus and Order(sub<G | g1, g2, g3>) eq Order(G) then
                    return [g1, g2, g3];
                end if;
            end for;
        end for;
    end for;
    return "FAIL";
end function;


SphGensUptoConj := function(G, conj : UseElements := false)
    conjClasses := ConjugacyClasses(G);
    // Create a list of elements for each conjugacy class
    if UseElements then
        // If UseElements is true, conj contains the actual elements
        el_Conjs := [[g : g in G | IsConjugate(G, g, c)] : c in conj];
    else
        // Original behavior - conj contains indices
        el_Conjs := [[g : g in G | IsConjugate(G, g, conjClasses[c][3])] : c in conj];
    end if;
    
    // Use CartesianProduct to generate all possible combinations
    list_of_gens := [];
    for tuple in CartesianProduct(el_Conjs) do
        tup := [g : g in tuple];
        if &* tup eq Id(G) and Order(sub<G | tup>) eq Order(G) then
            Append(~list_of_gens, tup);
        end if;
    end for;
    
    set_of_gens := {};
    representatives := {};
    for list in list_of_gens do
        if list notin set_of_gens then
            Include(~representatives, list);
            for g in G do
                Include(~set_of_gens, [x^g : x in list]);
            end for;
        end if;
    end for;
    return representatives;
end function;

// code to identify spherical generators up to Hurwitz moves

HurwitzMove:=
  function(seq,idx)
  return Insert(Remove(seq,idx),idx+1,seq[idx]^seq[idx+1]);
end function;

// This script, starting from a sequence of elements of a group,
// creates all sequences of elements which are equivalent to the 
// given one for the equivalence relation generated by Hurwitz 
// moves, and returns (to spare memory) only the ones whose 
// entries have never increasing  order.

HurwitzOrbit:=
  function(seq)
  orb:={ }; shortorb:={  }; Trash:={ seq };
    repeat
      ExtractRep(~Trash,~gens); Include(~orb, gens);
        for k in [1..#seq-1] do newgens:=HurwitzMove(gens,k);
        if newgens notin orb then Include(~Trash, newgens);
        end if; end for;
    until IsEmpty(Trash);
    for gens in orb do test:=true;
      for k in [1..#seq-1] do
        if Order(gens[k]) lt Order(gens[k+1]) then test:=false; break k;
        end if;
      end for;
      if test then Include(~shortorb, gens);
      end if;
    end for;
  return shortorb;
end function;


SphGensUptoHurwitz := function(G, conj : UseElements := false)
    conjClasses := ConjugacyClasses(G);
    // Create a list of elements for each conjugacy class
    if UseElements then
        // If UseElements is true, conj contains the actual elements
        el_Conjs := [[g : g in G | IsConjugate(G, g, c)] : c in conj];
    else
        // Original behavior - conj contains indices
        el_Conjs := [[g : g in G | IsConjugate(G, g, conjClasses[c][3])] : c in conj];
    end if;
    
    // Use CartesianProduct to generate all possible combinations
    list_of_gens := [];
    for tuple in CartesianProduct(el_Conjs) do
        tup := [g : g in tuple];
        if &* tup eq Id(G) and Order(sub<G | tup>) eq Order(G) then
            Append(~list_of_gens, tup);
        end if;
    end for;
    
    set_of_gens := {};
    representatives := {};
    for list in list_of_gens do
        if list notin set_of_gens then
            Include(~representatives, list);
            for g in G do
                Include(~set_of_gens, [x^g : x in list]);
            end for;
            set_of_gens join:= HurwitzOrbit(list);
        end if;
    end for;
    return representatives;
end function;

SphGensUptoAut := function(G, conj : UseElements := false)
    conjClasses := ConjugacyClasses(G);         
    // Create a list of elements for each conjugacy class
    if UseElements then
        el_Conjs := [[g : g in G | IsConjugate(G, g, c)] : c in conj];
    else
        el_Conjs := [[g : g in G | IsConjugate(G, g, conjClasses[c][3])] : c in conj];
    end if;
    
    // Use CartesianProduct to generate all possible combinations
    list_of_gens := [];
    for tuple in CartesianProduct(el_Conjs) do
        tup := [g : g in tuple];
        if &* tup eq Id(G) and Order(sub<G | tup>) eq Order(G) then
            Append(~list_of_gens, tup);
        end if;
    end for;
    
    set_of_gens := {};
    representatives := {};
    for list in list_of_gens do
        if list notin set_of_gens then
            Include(~representatives, list);
            for phi in Generators(AutomorphismGroup(G)) do
                for g in G do
                    Include(~set_of_gens, [phi(x)^g : x in list]);
                end for;
            end for;
        end if;
    end for;
    return representatives;
end function;

RationalityField := function(G, conj)
    m := Exponent(G);
    fixed_els := [];
    conjClasses := ConjugacyClasses(G);
    for i in [1..m-1] do
        if GCD(i, m) eq 1 then
            invariant := true;
            for j in [1..#conj] do
                if not IsConjugate(G, conjClasses[conj[j]][3]^i, conjClasses[conj[j]][3]) then
                    invariant := false;
                end if;
            end for;
            if invariant then
                Append(~fixed_els, i);
            end if;
        end if;
    end for;
    // Generate the fixed field of the cyclotomic field under the subgroup generated by fixed_els
    L<zeta> := CyclotomicField(m);
    fixed_field := FixedField(L, [hom<L -> L | zeta :-> zeta^i> : i in fixed_els]);
    return fixed_field;
end function;

WeakRationalityField := function(G, conj)
    m := Exponent(G);
    fixed_els := [];
    conjClasses := ConjugacyClasses(G);
    for i in [1..m-1] do
        if GCD(i, m) eq 1 then
            invariant := true;
            for j in [1..#conj] do
                checked := false;
                for phi in Generators(AutomorphismGroup(G)) do
                    if IsConjugate(G, conjClasses[conj[j]][3]^i, phi(conjClasses[conj[j]][3])) then
                        checked := true;
                        break;
                    end if;
                end for;
                if not checked then
                    invariant := false;
                end if;
            end for;
            if invariant then
                Append(~fixed_els, i);
            end if;
        end if;
    end for;
    // Generate the fixed field of the cyclotomic field under the subgroup generated by fixed_els
    L<zeta> := CyclotomicField(m);
    fixed_field := FixedField(L, [hom<L -> L | zeta :-> zeta^i> : i in fixed_els]);
    return fixed_field;
end function;

ActionOfCyclotomicField := function(G, seq, a, aut, representatives) // gives the action of 1 -> a in cyclotomic character of Aut(Q(zeta_m)) (with m := Expoenent(G)) on the sequence seq up to conjugacy in G or up to automorphism of G if aut = true
    new_seq := [g^a : g in seq];
    if aut then
        for list in representatives do
            for g in G do
                for phi in Generators(AutomorphismGroup(G)) do
                    if phi(list[1]^g) eq new_seq[1] and phi(list[2]^g) eq new_seq[2] and phi(list[3]^g) eq new_seq[3] then
                        return true, list;
                    end if;
                end for;
            end for;
        end for;
    else
        for list in representatives do
            for g in G do
                if list[1]^g eq new_seq[1] and list[2]^g eq new_seq[2] and list[3]^g eq new_seq[3] then
                    return true, list;
                end if;
            end for;
        end for;
    end if;
    return false, [];
end function;

SimultaneouslyConjugate := function(G, seq1, seq2)
    if not (#seq1 eq #seq2) then
        return false;
    end if;

    conjug_els := [];

    for i in [1..#seq1] do
        b, h := IsConjugate(G, seq1[i], seq2[i]); 
        if not b then 
            return false;
        else
            Append(~conjug_els, h);
        end if;
    end for;

    C := &meet [Centralizer(G, g) : g in seq1];
    for c in C do
        all_eq := true;
        for i in [1..#conjug_els] do
            if not (c*conjug_els[1] eq c*conjug_els[i]) then
                all_eq := false;
            end if;
        end for;
        if all_eq then 
            return true;
        end if;
    end for;
    return false;
end function;

if false then 

G := SL(2,8);
seq := FindBelyiCurve(G, [2,3,4], 7);
&* seq;
cl := ClassMap(G);
conj := cl(seq);


// test for Accola-Maclachlan curve of genus 15, looks like LMFDB labeled its conjugacy classes inconsitently 


G := SmallGroup(128,150);
seq := FindBelyiCurve(G, [2,9,19], 15);

S128 := SymmetricGroup(128);

seq := [
    S128 ! (1,33) (2,34) (3,36) (4,35) (5,39) (6,40) (7,37) (8,38) (9,42) (10,41) (11,43) (12,44) (13,48) (14,47) (15,46) (16,45) (17,54) (18,53) (19,55) (20,56) (21,50) (22,49) (23,51) (24,52) (25,61) (26,62) (27,64) (28,63) (29,57) (30,58) (31,60) (32,59) (65,97) (66,98) (67,100) (68,99) (69,103) (70,104) (71,101) (72,102) (73,106) (74,105) (75,107) (76,108) (77,112) (78,111) (79,110) (80,109) (81,118) (82,117) (83,119) (84,120) (85,114) (86,113) (87,115) (88,116) (89,125) (90,126) (91,128) (92,127) (93,121) (94,122) (95,124) (96,123),
    S128 !  	(1,73,9,65) (2,74,10,66) (3,76,11,68) (4,75,12,67) (5,79,13,71) (6,80,14,72) (7,77,15,69) (8,78,16,70) (17,93,25,85) (18,94,26,86) (19,96,27,88) (20,95,28,87) (21,89,29,81) (22,90,30,82) (23,92,31,84) (24,91,32,83) (33,121,41,113) (34,122,42,114) (35,124,43,116) (36,123,44,115) (37,127,45,119) (38,128,46,120) (39,125,47,117) (40,126,48,118) (49,106,57,98) (50,105,58,97) (51,107,59,99) (52,108,60,100) (53,112,61,104) (54,111,62,103) (55,110,63,102) (56,109,64,101),
    S128 ! (1,97,30,126,6,102,28,124,4,100,31,127,7,103,26,122,2,98,29,125,5,101,27,123,3,99,32,128,8,104,25,121) (9,106,22,117,14,109,20,115,12,107,23,120,15,112,18,113,10,105,21,118,13,110,19,116,11,108,24,119,16,111,17,114) (33,86,62,78,38,84,60,76,36,87,63,79,39,82,58,74,34,85,61,77,37,83,59,75,35,88,64,80,40,81,57,73) (41,93,54,69,46,91,52,67,44,96,55,72,47,89,50,65,42,94,53,70,45,92,51,68,43,95,56,71,48,90,49,66) 
];

&* seq;
G := sub<S128 | seq>;
cl := ClassMap(G);
conj := cl(seq);

// this is supposed to give [4,9,19] according to https://www.lmfdb.org/HigherGenus/C/Aut/15.128-150.0.2-4-32.5



// Hurwitz curve of genus 14
G := SmallGroups(1092)[25];
// reps := SphGensUptoHurwitz(G, [2,3,5]);
seq := FindBelyiCurve(G, [2,3,5], 14);

subgroups := [Subgroups(G)[i]`subgroup : i in [1..#Subgroups(G)]];

for i in [1..#subgroups] do
    H := subgroups[i];
    print i, GenusIntermediateExtension(G, seq, H);
end for; 

// Accola-Maclachlan curve of genus 15

G := SmallGroup(128,150);
seq := FindBelyiCurve(G, [4,8,20], 15);

print seq;

subgroups := [Subgroups(G)[i]`subgroup : i in [1..#Subgroups(G)]];

for i in [1..#subgroups] do
    H := subgroups[i];
    print i, GenusIntermediateExtension(G, seq, H);
    H := sub<G | H>;
    print i, Order(H), Order(Normalizer(G, H));
end for; 


// Accola-Maclachlan curve of genus 13

S := SymmetricGroup(112);

seq := [
S! (1,71) (2,77) (3,76) (4,75) (5,74) (6,73) (7,72) (8,78) (9,84) (10,83) (11,82) (12,81) (13,80) (14,79) (15,57) (16,63) (17,62) (18,61) (19,60) (20,59) (21,58) (22,64) (23,70) (24,69) (25,68) (26,67) (27,66) (28,65) (29,106) (30,112) (31,111) (32,110) (33,109) (34,108) (35,107) (36,99) (37,105) (38,104) (39,103) (40,102) (41,101) (42,100) (43,92) (44,98) (45,97) (46,96) (47,95) (48,94) (49,93) (50,85) (51,91) (52,90) (53,89) (54,88) (55,87) (56,86),
S!	(1,108,22,87) (2,107,23,86) (3,106,24,85) (4,112,25,91) (5,111,26,90) (6,110,27,89) (7,109,28,88) (8,101,15,94) (9,100,16,93) (10,99,17,92) (11,105,18,98) (12,104,19,97) (13,103,20,96) (14,102,21,95) (29,59,50,80) (30,58,51,79) (31,57,52,78) (32,63,53,84) (33,62,54,83) (34,61,55,82) (35,60,56,81) (36,66,43,73) (37,65,44,72) (38,64,45,71) (39,70,46,77) (40,69,47,76) (41,68,48,75) (42,67,49,74),
S!	(1,55,18,37,7,54,17,36,6,53,16,42,5,52,15,41,4,51,21,40,3,50,20,39,2,56,19,38) (8,48,25,30,14,47,24,29,13,46,23,35,12,45,22,34,11,44,28,33,10,43,27,32,9,49,26,31) (57,111,74,93,63,110,73,92,62,109,72,98,61,108,71,97,60,107,77,96,59,106,76,95,58,112,75,94) (64,104,81,86,70,103,80,85,69,102,79,91,68,101,78,90,67,100,84,89,66,99,83,88,65,105,82,87)
];

G := sub<S | seq>;
Order(G);

&* seq;

C := ConjugacyClasses(G);

for g in seq do
    for i in [1..#C] do
        if IsConjugate(G, g, C[i][3]) then
            print i;
        end if;
    end for;
end for;

subgroups := [Subgroups(G)[i]`subgroup : i in [1..#Subgroups(G)]];

for i in [1..#subgroups] do
    H := subgroups[i];
    print i, GenusIntermediateExtension(G, seq, H);
    H := sub<G | H>;
    print i, Order(H), Order(Normalizer(G, H));
end for; 



G := SmallGroups(112)[13];
seq := FindBelyiCurve(G, [32,10,6], 13);

subgroups := [Subgroups(G)[i]`subgroup : i in [1..#Subgroups(G)]];

for i in [1..#subgroups] do
    H := subgroups[i];
    print i, GenusIntermediateExtension(G, seq, H);
    H := sub<G | H>;
    print i, Order(H), Order(Normalizer(G, H));
end for; 


        
// Hurwitz curve of genus 14

G := SmallGroups(1092)[25];
reps := SphGensUptoConj(G, [2,3,5]);
seq := FindBelyiCurve(G, [2,3,5], 14);

/*
m := Exponent(G);
for a in [1..m-1] do // test if the cyclotomic character permutes the sequence up to conjugacy
    if GCD(a, m) eq 1 then
        succ, act := ActionOfCyclotomicField(G, seq, a, false, reps);
        if succ then
            print a, act;
            if not (act eq seq) then
                print "FLIP";
            end if;
        end if;
    end if;
end for;

RationalityField(G, [2,3,5]); */
seq;

subgroups := [Subgroups(G)[i]`subgroup : i in [1..#Subgroups(G)]];

H := subgroups[7];
print GenusIntermediateExtension(G, seq, H);
action := CosetAction(G, H);
perm1 := [action(g) : g in seq];

H := subgroups[9];
print GenusIntermediateExtension(G, seq, H);
action := CosetAction(G, H);
perm2 := [action(g) : g in seq];

S := SymmetricGroup(Floor(Order(G)/Order(H)));
perm1 := [S ! p : p in perm1];
perm2 := [S ! p : p in perm2];

print SimultaneouslyConjugate(S, perm1, perm2);

for i in [1..#subgroups] do
    H := subgroups[i];
    print i, GenusIntermediateExtension(G, seq, H);
    H := sub<G | H>;
    print i, Order(H), Order(Normalizer(G, H));
end for; 



G := SL(2, 13);
Aut := AutomorphismGroup(G);

M := GL(2,13) ! [[2,0],[0,1]];
f := hom<G -> G | x :-> M*x*M^(-1)>;
// check which subgroups are invariant under outer automorphisms
subgroups := [Subgroups(G)[i]`subgroup : i in [1..#Subgroups(G)]];
for i in [1..#subgroups] do
    H := subgroups[i];
    print i;
    print IsConjugate(G, H, f(H));
    /*for h in Generators(Aut) do
        print IsConjugate(G, h(H), H);
    end for;*/
end for;

// Max automorphisms for g = 10

G := SmallGroups(432)[734];
seq := FindBelyiCurve(G, [3,6,10], 10);

// Max automorphisms for g = 13

G := SmallGroups(360)[121];
seq := FindBelyiCurve(G, [4,7,12], 13);

subgroups := [Subgroups(G)[i]`subgroup : i in [1..#Subgroups(G)]];

for i in [1..#subgroups] do
    H := subgroups[i];
    print i, GenusIntermediateExtension(G, seq, H);
end for; 
 

// Max automorphisms for g = 10
//G := SmallGroups(432)[743];
// conjClasses := ConjugacyClasses(G);
// seq := [conjClasses[3][3], conjClasses[6][3], conjClasses[10][3]];
// computeRationalCohomology(G, seq);
// computeGroupRingDecomposition(G, seq);


/*SubgroupLattice(G);
subgroups := [Subgroups(G)[i]`subgroup : i in [1..#Subgroups(G)]];

for i in [1..#Subgroups(G)] do
    H := subgroups[i];
    print i, GenusIntermediateExtension(G, seq, H);
end for; */

// H := subgroups[8];
// HL := subgroups[15];
// H_seq, G_seq := IntermediateMonodromy(G, seq, H);    
//HL_H_seq, G_HL_seq := GetMonodromyIntermediateExtension(G, seq, H, HL);

G := SmallGroups(1092)[25];
seq := [
    G ! (1, 2)(3, 4)(5, 8)(6, 9)(7, 12)(13, 14),
    G ! (1, 11, 8)(2, 9, 3)(4, 13, 6)(10, 14, 12),
    G ! (1, 5, 8, 11, 2, 4, 9)(3, 6, 14, 10, 7, 12, 13)
];

H := (Subgroups(G)[13])`subgroup;

H_seq, G_seq := IntermediateMonodromy(G, seq, H);


// EXAMPLES 

G := SL(2, GF(3));

x1 := G ! [[2,0],[0,2]]; /* monodromy around lambda */
x2 := G ! [[1,2],[0,1]]; /* monodromy around 0 */
x3 := G ! [[1,0],[1,1]]; /* monodromy around 1 */
x4 := G ! [[2,2],[1,0]]; /* monodromy around inf */

seq := [x1,x2,x3,x4]; 

G := SmallGroups(18)[3];
seq := [ G.1 * G.2^2 * G.3, G.2^2, G.3, G.2^2 * G.3, G.1 ];
// seq := [ G.1 * G.2^2 * G.3, G.2 * G.3^2, G.2^2 * G.3, G.2 * G.3, G.1 * G.3^2 ]; 

end if;