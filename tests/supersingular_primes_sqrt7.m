/*******************************************************************************
 * supersingular_primes_sqrt7.m
 *
 * Purpose:
 *   Analyze supersingular primes for the elliptic curve 2.2.28.1-16.1-a1
 *   defined over Q(sqrt(7)). Supersingular primes are those where the
 *   Frobenius trace is divisible by p, indicating supersingular reduction.
 *   Question: where did this example come from? It has CM by sqrt(-15). Why only inert primes?
 *
 * Method:
 *   1. Define K = Q(sqrt(7)) and the elliptic curve E over K
 *   2. For each rational prime p that is inert in K and of good reduction:
 *      - Compute the unique prime PP of K above p
 *      - Check if TraceOfFrobenius(E, PP) ≡ 0 (mod p)
 *   3. Also compute torsion over K(i)
 *
 * Output:
 *   - List of inert supersingular primes up to bound 1000
 *   - For each: the prime norm and its residue class mod 12
 *   - Torsion subgroup over K(i)
 *
 * Related files:
 *   - elliptic_curve_sqrt7.m: Analyize this elliptic curve
 *   - test_supersingular_primes_Hur14.m: Elliptic curve in the isogeny decomposition of Hur14
 *
 * LMFDB reference:
 *   https://www.lmfdb.org/EllipticCurve/2.2.28.1/16.1/a/1
 ******************************************************************************/

// Define the base number field: Q(sqrt(7))
R<x> := PolynomialRing(Rationals()); K<a> := NumberField(R![-7, 0, 1]);

// Define the curve:
E := EllipticCurve([K![1,1],K![0,1],K![1,1],K![0,0],K![-1,0]]);

// Define the conjugate curve:
Econj := EllipticCurve([K![1,-1],K![0,-1],K![1,-1],K![0,0],K![-1,0]]); // we can check that these are isogenous over K via LMFDB
Ea2 := EllipticCurve([K![1,1],K![0,1],K![0,0],K![4,3],K![8,0]]);
IsIsomorphic(Ea2, Econj);

// elliptic curve X_0(49) with CM by Q(sqrt(-7)) 
// Define the curve: 
E_X0_49 := EllipticCurve([1, -1, 0, -2, -1]);


ZK := RingOfIntegers(K);

D := Discriminant(ZK);
Del := Discriminant(E);

// Find inert supersingular primes: primes p inert in K with trace ≡ 0 (mod p)
function print_traces(E, bound)
  pps := PrimesUpTo(bound); // primes of Q
  for pp in pps do
    if (not pp eq 2) and (not Norm(ZK * Del) mod pp eq 0) then // only look at inert primes of good reduction
        PP := Factorization(pp * ZK)[1][1];
        if TraceOfFrobenius(E, PP) mod pp eq 0 then
            print "Supersingular prime, is split: ", (LegendreSymbol(D, pp)+1)/2, "mod 7: ", pp mod 7, "mod 4: ", pp mod 4, "mod 3: ", pp mod 3, "E_X0_49 is supersingular: ", (TraceOfFrobenius(E_X0_49, pp) mod pp eq 0), "Prime of K with characteristic: ", pp, "Norm: ", Norm(PP), "Trace: ", TraceOfFrobenius(E, PP);
        end if;
    end if;
  end for;
  return true;
end function;

print_traces(E, 100);

// Extend to K(i) and compute torsion
K_i := ext<K | PolynomialRing(K)![1, 0, 1]>;
E_i := BaseChange(E, K_i);
TorsionSubgroup(E_i);

// Compute the Galois representation on E[4]
// 4-division polynomial in x
psi4 := DivisionPolynomial(E, 4);

// Field generated by x-coordinates of 4-torsion
Kx, mKx := SplittingField(psi4);

// We want to view Kx as an extension of K and compute the automorphisms of Kx fixing K.

G, auts, f := AutomorphismGroup(Kx);   

for H in Subgroups(G) do
    printf "Subgroup of order %o: ", #H`subgroup;
    print IdentifyGroup(H`subgroup);
    FF := FixedField(Kx, H`subgroup);
    print "Fixed field of this subgroup has degree", Degree(FF);
    print "Discriminant", Discriminant(RingOfIntegers(FF));
    print "Defining polynomial of fixed field:", DefiningPolynomial(FF);
    print "------";
end for;

if false then



// The automorphism group of Kx over K:
AutKx := AutomorphismGroup(Kx, K);

// Print info about the automorphisms
print "Number of automorphisms of Kx over K:", #AutKx;
for i in [1..#AutKx] do
    print "Automorphism", i, ":", AutKx[i];
end for;


// Build the full 4-division field by adjoining y-coordinates for all x-roots
a1, a2, a3, a4, a6 := Explode(aInvariants(E));
K4 := Kx;
mK4 := mKx; // embedding K -> K4
for r in Roots(psi4, Kx) do
    x0 := K4!r[1];
    S<y> := PolynomialRing(K4);
    f := y^2 + (a1*x0 + a3)*y - (x0^3 + a2*x0^2 + a4*x0 + a6);
    if IsIrreducible(f) then
        K4, m := ext<K4 | f>;
        mK4 := m * mK4; // compose embeddings K -> K4_old -> K4
    end if;
end for;

E4 := BaseChange(E, K4);

// Pick a Z/4Z-basis of E[4]
T4, toE4 := TorsionSubgroup(E4);
T := [toE4(g) : g in T4 | 4*toE4(g) eq E4!0];
function is_independent(P, Q)
    for a in [0..3] do
        for b in [0..3] do
            if (a ne 0 or b ne 0) and (a*P + b*Q eq E4!0) then
                return false;
            end if;
        end for;
    end for;
    return true;
end function;

P := T[1];
Q := T[2];
found := false;
for i in [1..#T] do
    for j in [i+1..#T] do
        if is_independent(T[i], T[j]) then
            P := T[i];
            Q := T[j];
            found := true;
            break;
        end if;
    end for;
    if found then
        break;
    end if;
end for;

// Use the explicit embedding of K into K4
K_sub := sub< K4 | [mK4(K.1)] >;
G, m := GaloisGroup(K4, K_sub);

function sigma_point(sigma, P)
    x := sigma(P[1]);
    y := sigma(P[2]);
    return E4![x,y];
end function;

function coords_in_basis(R, P, Q)
    // brute force search in (Z/4Z)^2
    for a in [0..3] do
        for b in [0..3] do
            if a*P + b*Q eq R then
                return a,b;
            end if;
        end for;
    end for;
    error "Not in span";
end function;

images := [];
for sigma in G do
    P1 := sigma_point(m(sigma), P);
    Q1 := sigma_point(m(sigma), Q);
    a,b := coords_in_basis(P1, P, Q);
    c,d := coords_in_basis(Q1, P, Q);
    Append(~images, Matrix(Integers(4),2,2,[a,b,c,d]));
end for;

end if;